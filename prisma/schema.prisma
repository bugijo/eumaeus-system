// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Para controlar o status do agendamento de forma padronizada
enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
}

// Para controlar o status das faturas
enum InvoiceStatus {
  PENDING
  PAID
  CANCELLED
}

// 1. Modelo para o Tutor (Dono do Pet) modificado
model Tutor {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  email     String   @unique // Mantemos o email aqui para comunicação
  phone     String
  address   String?  // O '?' indica que o campo é opcional
  clinicId  Int      @default(1) // Essencial para a V2 Multi-Tenant no futuro
  deletedAt DateTime? // Soft delete: quando preenchido, o registro está "excluído"

  // Relacionamento: Um Tutor pode ter vários Pets
  pets         Pet[]
  appointments Appointment[]
}

// 2. Modelo para o Pet
model Pet {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  species   String   // Ex: "Cachorro", "Gato"
  breed     String   // Ex: "SRD", "Poodle"
  birthDate DateTime?
  deletedAt DateTime? // Soft delete: quando preenchido, o registro está "excluído"

  // Relacionamento: Um Pet pertence a um Tutor
  tutorId      Int
  tutor        Tutor    @relation(fields: [tutorId], references: [id])
  appointments Appointment[]
}

// 3. Modelo para o Agendamento
model Appointment {
  id              Int      @id @default(autoincrement())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  appointmentDate DateTime
  status          AppointmentStatus @default(SCHEDULED)
  notes           String?

  // Relacionamento: Um agendamento é para um Pet
  petId           Int
  pet             Pet      @relation(fields: [petId], references: [id])
  
  // Relacionamento: E pertence a um Tutor
  tutorId         Int
  tutor           Tutor    @relation(fields: [tutorId], references: [id])

  // Relacionamento: Um agendamento gera um prontuário (1-para-1)
  medicalRecord   MedicalRecord?

  // Relacionamento: Um agendamento pode ter vários serviços (consulta, vacina, etc.)
  services        Service[]

  // Relacionamento: Um agendamento pode gerar uma fatura (1-para-1)
  invoice         Invoice?
}

// 4. Modelo para o Prontuário Eletrônico
model MedicalRecord {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  symptoms      String
  diagnosis     String
  treatment     String
  notes         String?

  // Relacionamento: O prontuário pertence a um agendamento
  appointmentId Int      @unique // @unique garante que cada agendamento só tenha um prontuário
  appointment   Appointment @relation(fields: [appointmentId], references: [id])

  // Relacionamento: Many-to-many com produtos utilizados
  products      MedicalRecordProduct[]

  // Relacionamento: Um prontuário pode ter uma receita (1-para-1)
  prescription  Prescription?
}

// 4.3. Modelo para Receituário Digital
model Prescription {
  id              Int                 @id @default(autoincrement())
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  medicalRecordId Int                 @unique // Cada prontuário só pode ter uma receita associada
  medicalRecord   MedicalRecord       @relation(fields: [medicalRecordId], references: [id])

  items           PrescriptionItem[]
}

// 4.4. Modelo para Itens do Receituário
model PrescriptionItem {
  id          Int          @id @default(autoincrement())
  medication  String
  dosage      String
  frequency   String
  duration    String
  instructions String?

  prescriptionId Int
  prescription   Prescription @relation(fields: [prescriptionId], references: [id])
}

// 4.1. Modelo para registrar produtos utilizados no prontuário
model MedicalRecordProduct {
  id              Int           @id @default(autoincrement())
  quantityUsed    Int
  
  // Relacionamentos
  medicalRecordId Int
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id])
  
  productId       Int
  product         Product       @relation(fields: [productId], references: [id])

  @@unique([medicalRecordId, productId]) // Evita duplicatas do mesmo produto no mesmo prontuário
}

// 4.2. Modelo para Produtos/Estoque
model Product {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  name        String
  description String?
  quantity    Int      @default(0)
  price       Float
  category    String?  // Ex: "Medicamento", "Vacina", "Material"

  // Relacionamento: Many-to-many com prontuários
  medicalRecords MedicalRecordProduct[]
}

// 5. Modelo para Serviços e Produtos (para faturamento)
model Service {
  id            Int      @id @default(autoincrement())
  name          String   // Ex: "Consulta", "Vacina V10", "Raio-X"
  price         Float
  
  // Relacionamento: O serviço está vinculado a um agendamento
  appointmentId Int
  appointment   Appointment @relation(fields: [appointmentId], references: [id])
}

// Enum para garantir que os nomes dos cargos sejam sempre os mesmos
enum RoleName {
  DONO
  VETERINARIO
  FUNCIONARIO
  FINANCEIRO
}

// Modelo central que lida APENAS com login
model AuthProfile {
  id           Int     @id @default(autoincrement())
  email        String  @unique
  password     String  // O hash da senha, como já fazemos
  refreshToken String? @unique
  createdAt    DateTime @default(now())

  // A que tipo de perfil este login pertence?
  // A relação é opcional em ambos os lados, pois um AuthProfile
  // pertence a um User.
  user   User?
}

// Modelo User (funcionário) modificado
model User {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int      @default(1) // Essencial para a V2 Multi-Tenant no futuro

  // Relacionamento: Um usuário tem um cargo
  roleName  RoleName
  role      Role     @relation(fields: [roleName], references: [name])

  // Relacionamento 1-para-1 com AuthProfile
  authProfileId Int         @unique
  authProfile   AuthProfile @relation(fields: [authProfileId], references: [id], onDelete: Cascade)
}

// O modelo para os Cargos (ou "Roles")
model Role {
  name        RoleName       @id @unique
  description String?
  users       User[]
  // Relacionamento: Um cargo tem muitas permissões
  permissions Permission[]
}

// O modelo para as Permissões individuais
model Permission {
  id          Int      @id @default(autoincrement())
  action      String   // Ex: "view", "create", "edit", "delete"
  subject     String   // Ex: "Tutor", "Pet", "Appointment", "Financials", "MedicalRecord"

  // Relacionamento: Uma permissão pode estar em muitos cargos
  roles       Role[]

  @@unique([action, subject]) // Garante que não tenhamos permissões duplicadas (ex: duas "view_Tutor")
}

// 6. Modelo para Faturas
model Invoice {
  id            Int           @id @default(autoincrement())
  totalAmount   Float
  status        InvoiceStatus @default(PENDING)
  createdAt     DateTime      @default(now())
  nfeId         String?       // ID da NFS-e emitida (opcional)

  appointmentId Int           @unique // Cada fatura está ligada a um único agendamento
  appointment   Appointment   @relation(fields: [appointmentId], references: [id])

  items         InvoiceItem[]
}

// 6.1. Modelo para Itens da Fatura
model InvoiceItem {
  id          Int     @id @default(autoincrement())
  description String  // Ex: "Consulta Padrão" ou "Vacina V10"
  quantity    Int
  unitPrice   Float
  totalPrice  Float   // quantity * unitPrice

  invoiceId   Int
  invoice     Invoice @relation(fields: [invoiceId], references: [id])
}
